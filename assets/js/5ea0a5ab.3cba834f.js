"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6822],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=u(n),d=r,h=m["".concat(l,".").concat(d)]||m[d]||p[d]||s;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var u=2;u<s;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},33678:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return c},default:function(){return m}});var a=n(87462),r=n(63366),s=(n(67294),n(3905)),i=["components"],o={sidebar_position:5,sidebar_label:"Rath \u2764\ufe0f Turms"},l="Rath \u2764\ufe0f Turms",u={unversionedId:"turms",id:"turms",title:"Rath \u2764\ufe0f Turms",description:"What is turms?",source:"@site/docs/turms.md",sourceDirName:".",slug:"/turms",permalink:"/rath/docs/turms",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/turms.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,sidebar_label:"Rath \u2764\ufe0f Turms"},sidebar:"tutorialSidebar",previous:{title:"Sync, Async and Qt",permalink:"/rath/docs/sync_async"},next:{title:"errors",permalink:"/rath/docs/reference/errors"}},c=[{value:"What is turms?",id:"what-is-turms",children:[],level:3},{value:"Inspiration",id:"inspiration",children:[],level:3},{value:"Turms",id:"turms",children:[],level:3}],p={toc:c};function m(e){var t=e.components,n=(0,r.Z)(e,i);return(0,s.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"rath-\ufe0f-turms"},"Rath \u2764\ufe0f Turms"),(0,s.kt)("h3",{id:"what-is-turms"},"What is turms?"),(0,s.kt)("p",null,"Turms is a graphql-codegen inspired code generator for python that generates fully typed and\nserialized operations from your graphql schema. Just define your query in standard graphql syntax\nand let turms create fully typed queries/mutation and subscriptions, that you can use in your favourite\nIDE and with your favourite client like rath."),(0,s.kt)("h3",{id:"inspiration"},"Inspiration"),(0,s.kt)("p",null,"Imaging you have a schema like this"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-graphql",metastring:'title="schema.graphql"',title:'"schema.graphql"'},'type Beast {\n  "ID of beast (taken from binomial initial)"\n  id: ID\n  "number of legs beast has"\n  legs: Int\n  "a beast\'s name in Latin"\n  binomial: String\n  "a beast\'s name to you and I"\n  commonName: String\n  "taxonomy grouping"\n  taxClass: String\n  "a beast\'s prey"\n  eats: [Beast]\n  "a beast\'s predators"\n  isEatenBy: [Beast]\n}\n\ntype Query {\n  beasts: [Beast]\n  beast(id: ID!): Beast\n  calledBy(commonName: String!): [Beast]\n}\n\ntype Mutation {\n  createBeast(\n    id: ID!\n    legs: Int!\n    binomial: String!\n    commonName: String!\n    taxClass: String!\n    eats: [ID]\n  ): Beast\n}\n\ntype Subscription {\n  watchBeast(id: ID!): Beast\n}\n')),(0,s.kt)("p",null,"And in your python code you would like to query all of the beasts"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-graphql",metastring:'title="/graphql/test.graphql"',title:'"/graphql/test.graphql"'},"fragment Beast on Beast {\n  commonName\n  taxClass\n}\n\nquery get_beasts {\n  beasts {\n    ...Beast\n  }\n}\n")),(0,s.kt)("p",null,"In normal rath logic you would write the code something like this"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python"},'\nrath = Rath(AIOHttpLink(url="..."))\n\nwith rath:\n    result = rath.execute("""\n      fragment Beast on Beast {\n      commonName\n      taxClass\n    }\n\n    query get_beasts {\n      beasts {\n        ...Beast\n      }\n    }\n    """)\n\n    first_beast_name = result.data["get_beasts"][0]["commonName"]\n\n')),(0,s.kt)("p",null,"This would be a perfectly fine scenario, however accessing nested dictionaries, can lead to unexpected\nbugs when accessing by wrongly spelled keys and especially is hard to debug if there are ever changes to your api.\nWouldn't it be nice to have the type safety of graphql in your python code?"),(0,s.kt)("h3",{id:"turms"},"Turms"),(0,s.kt)("p",null,"Turms can generate pydantic models that are automatically validated through your schema and makes working with\ngraphql fragments and operations super easy."),(0,s.kt)("p",null,"Turms requires a graphl.config.yaml file to generate code, for this\nexample we can use the following:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-yaml"},"projects:\n  default:\n    schema: schema.graphql\n    documents: graphql/**.graphql\n    extensions:\n      turms:\n        out_dir: api\n        stylers:\n          - type: turms.stylers.capitalize.Capitalizer\n        plugins:\n          - type: turms.plugins.enums.EnumsPlugin\n          - type: turms.plugins.fragments.FragmentsPlugin\n          - type: turms.plugins.operation.OperationsPlugin\n          - type: rath.turms.plugins.funcs.RathFuncsPlugin #this will create functions that we can use with rath\n        processors:\n          - type: turms.processor.black.BlackProcessor\n        scalar_definitions:\n          uuid: str\n")),(0,s.kt)("p",null,"With this generation rath will generate fully typed classes for enums, fragments, operations and additionally\nbecause we specify the RathFuncsPlugin, fully typed functions that we you can use in your code (ala useQuery, useMutation in apollo)."),(0,s.kt)("p",null,"On running (in your terminal)"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"turms gen\n")),(0,s.kt)("p",null,"Turms generates automatically this pydantic schema for you"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="api/schema.py"',title:'"api/schema.py"'},'from typing import Literal, List, Optional\nfrom pydantic import Field, BaseModel\nfrom enum import Enum\nfrom rath.turms.funcs import aexecute, execute\n\n\nclass Beast(BaseModel):\n    typename: Optional[Literal["Beast"]] = Field(alias="__typename")\n    commonName: Optional[str]\n    "a beast\'s name to you and I"\n    taxClass: Optional[str]\n    "taxonomy grouping"\n\n\nclass Get_beasts(BaseModel):\n    beasts: Optional[List[Optional[Beast]]]\n\n    class Meta:\n        domain = "default"\n        document = "fragment Beast on Beast {\\n  commonName\\n  taxClass\\n}\\n\\nquery get_beasts {\\n  beasts {\\n    ...Beast\\n  }\\n}"\n\n\ndef get_beasts() -> List[Beast]:\n    """get_beasts\n\n\n\n    Arguments:\n\n    Returns:\n        Beast: The returned Mutation"""\n    return execute(Get_beasts, {}).beasts\n\n\nasync def aget_beasts() -> List[Beast]:\n    """get_beasts\n\n\n\n    Arguments:\n\n    Returns:\n        Beast: The returned Mutation"""\n    return (await aexecute(Get_beasts, {})).beasts\n')),(0,s.kt)("p",null,"Which you can than use easily in your application code, like this"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python"},'from rath import Rath\nfrom api import get_beasts\n\nrath = Rath(AIOHttpLink(url="..."))\n\nwith rath:\n    beasts = get_beasts()\n    first_beast_name = beasts[0].commonName\n\n')),(0,s.kt)("p",null,"Your Queries are now strongly typed, with comments from your schema."),(0,s.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"RathFuncs is just a thin wrapper aorund the OperationsFuncsPlugin that comes with turms,\ncheck out ",(0,s.kt)("inlineCode",{parentName:"p"},"rath.turms.funcs")," for inspiraiton on writing your own."))))}m.isMDXComponent=!0}}]);